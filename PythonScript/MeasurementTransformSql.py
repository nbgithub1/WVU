#Libraries for running this program. 
#csv (built in library) for CSV read and write operations. 
#MySQLdb (need to install this  if not already in machine, using - pip3 install mysqlclient) for connecting MySqlDB databases and executing stored procedures and retrieving data.
#os for reading the environment varaible
import csv
import MySQLdb
import os

"""
Author  : Nethan Binu
Purpose : Pivot data generated by openPDC for various Measurement Key(s) with a timestamp and value in SQL tables to csv files         
        Output file has rows of data for each Timestamp with Columns as Timestamp, Measurement Key(s) (each as a separate column) 
"""

#-----Variables declared-----
#server IP Address hosting sql --change this value********************
hostIPAddress = '192.xxx.x.xx'
#MySQL user name to connect --change this value************** 
mySQLUserName = 'root'
#output File Name --change this value to give a new name for outputfile
outFileName = 'NewFormatFromDB.csv'

#database name of openPDC configuration and measurement databases
measurementDBName =  'measurements'
openPDCDBName =  'openpdc'
#sql table name for reading signalid, timestamp, value
measurementTableName= 'measurementtimestamp'
#sql view name for reading other measurement details such as description
measurementDetailTableName= 'measurementdetail'
#column names
keyColumnName = 'Description'
idColumnName = 'SignalID' 

#uniqueKeys list will store the unique values of Measurement Key , e.g. PPA:5 , PPA:8
uniqueKeys = [] 
#initializing a Dictionary object (with first row key as 'Timestamp') to store the data in the new format for the output file
timeDict = {'Timestamp':[]} 

#password for connecting to sql, this environment variable has to be created before running the program
#or you can hardcode the password here as the value of the db_password = 'xxxx'
db_password = os.environ.get('DB_PASS')

#function to make a sql connection 
def connection():
    conn = MySQLdb.connect(
        host=hostIPAddress,
        user=mySQLUserName, 
        password=db_password,
        db=measurementDBName,
    )
    return conn

#------Step 1: Read all unique values of the key column (e.g. keyColumnName=Description as used here)
# by calling Stored Procedure 'GetKeys'
conn = connection()
cur = conn.cursor()
cur.callproc('GetKeys',[measurementTableName,measurementDetailTableName,keyColumnName,idColumnName,measurementDBName,openPDCDBName])


#------Step 2: Find unique keys for building columns for the output file
#unique 'key values' from cursor 'cur' is added to list uniqueKeys 
for row in cur:
    for field in row:
        uniqueKeys.append(field) 
cur.close()

#------Step 3: Adding first row data for the output file
#setting headers for first row with key = 'Timestamp'
timeDict['Timestamp'] = uniqueKeys

#------Step 4: Building a list object to use as template for each row created for a timestamp
#for each unique measurementkey, a value of '0' is added to the template 
rowInit = []
for i in range(len(uniqueKeys)):
    rowInit.append(0)

#------Step 5:Read measurement data from Stored Procedure 'GetMeasurementDetails'
cur = conn.cursor()
cur.callproc('GetMeasurementDetails',[measurementTableName,measurementDetailTableName,keyColumnName,idColumnName,measurementDBName,openPDCDBName])

#------Step 6:Read all the data from 'cur' and loop
i = 0
for line in cur.fetchall():
    # ------Step 6(a): reading each row 
    # line is a list, line[0] is signal ID, line[1] is measurement key, line[2] is timestamp, line[3] is value            
    time = line[2] 
    measurementKey = line[1]
    readingValue = line[3]

    # ------Step 6(b):making a copy of the row template for output dictionary            
    rowData = rowInit.copy() 
     
    # ------Step 6(c):finding row from output 'timeDict' by timestamp as key 
    if time in timeDict.keys():
        rowData =timeDict[time]   
         
    # ------Step 6(d):finding the index of machineKey from uniqueKeys and updating the value in output row    
    index = uniqueKeys.index(measurementKey)
    rowData[index] = readingValue

    # ------Step 5(e): adding or updating the output row to output dictinary
    timeDict[time] = rowData

#closing cursor     
cur.close()

#------Step 7:Writing to CSV file by the name given in 'outputFileName'
#open a file to write
#loop for each row in output dictionary 'timeDict'
outputFile = open(outFileName, "w")
for k, v in timeDict.items():  
    #k is timestamp, v is measurement key(s) list of values

    #------Step 7(a): Column 1 for timestamp 
    lineToWrite = str(k) + ',' #First will write the Timestamp    

    #------Step 7(b): Columns for each unique measurement key 
    #build a loop for uniquekeys count 
    machineKeyCount = len(uniqueKeys)
    for i in range(len(uniqueKeys)):   
        #append column data (which is measurement key value) to 'lineToWrite'              
        lineToWrite = lineToWrite + str(v[i])    
        #add a comma after each measurement key value (except for the last column)                                                                                                                      
        if machineKeyCount > 1:
            lineToWrite = lineToWrite + ','
            machineKeyCount = machineKeyCount - 1

    #------Step 7(c): #Writes "Timestamp, PPA7, PPA2" and creates a new line.     
    lineToWrite = lineToWrite + '\n' 

    #------Step 7(d): writes to file
    outputFile.write(lineToWrite)

#------Step 7: output file closed
outputFile.close()